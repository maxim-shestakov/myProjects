const fnWithError = () => {
    throw new Error('Some error') //Выброс ошибки
}

//fnWithError() //Код не пойдёт дальше после вызова функции, так как она выдаст ошибку КОММЕНТАРИЙ ДЛЯ ВЫПОЛНЕНИЯ СЛЕДУЮЩЕГО БЛОКА КОДА

console.log('Continue...')

//Обработка ошибки!!!

try {
    // Выполнение блока кода
} catch (error) {
    // Этот блок выполняется в случае возникновения ошибок в блоке try
}

//Обработка ошибки на примере функции выше: 

const fnWithProcessingError = () => {
    throw new Error('Some Error')
}

try {
    fnWithProcessingError()
} catch (error) {
    console.error(error) //Вывод целой ошибки с пометкой, метод error
    console.log(error.message) //Вывод сообщения об ошибке
}

console.log('Continue')

//Инструкции - объявления переменной через let (пример), выполняет определённые действия

//Выражение - всегда возвращает значение

//Выражение-инструкция

let a

const b = 5;

if (a > b) {
    console.log('a is larger');
}

for (let i = 0; i++; i<5) {
    console.log(i); 
} //После фигурных не требуется ";"

//Инструкции следует завершать ";", разделять их пустыми строками, все 4 примера выше - инструкции

//Точку с запятой можно опускать!!!

//Выражение может быть инструкцией

//'abc';

//a = a+3;

//c = a+b;

//d = 'Good '+'Evening';

//myFunction(c,d);

console.log('Hey');

//Если выражение написано на отдельной строке или с точкой с запятой, то оно является выражением-инструкицей

//Отличие!!! Выражения могут быть использованы как аргументы в вызовах функций!!! А инструкции нет


function myFn(a) {
    console.log(a);
}

const d = true;
let c = 10;

myFn(2+3) //5
myFn(d) //true
myFn(c=c+1) //11, да-да, это тоже выражение, так как это присваивание
//myFn(c=c+1;)  Инструкции в аргументах вызовут ошибки, как в строке ниже тоже
//myFn(let e)

//Для проверки можно передать как аргумент выражение/инструкцию и определить, чем же оно всё-таки является

